import { getUserPermissions } from '../accessControl.js';
import { loadHomeSections } from '../utils/homeSections.js';
import { getAvailablePages } from '../utils/pageRegistry.js';

class HomePageManager {
    constructor() {
        // Sections will be loaded dynamically from Firestore
        this.sections = [];
    }

    async initialize() {
        console.log('üè† Initializing Home Page Manager...');
        await this.loadSections();
        await this.renderSections();
        await this.loadActionItems(); // Load action items
        this.setupEventListeners();
        
        // Listen for page registry updates to refresh home sections
        window.addEventListener('pageRegistryUpdated', () => {
            console.log('üîÑ Page registry updated, refreshing home sections...');
            this.renderSections();
        });
    }

    async loadSections() {
        try {
            console.log('üè† Loading sections from Firestore...');
            const sectionsData = await loadHomeSections();
            
            // Convert Firestore sections to the format expected by the UI
            this.sections = sectionsData
                .filter(section => section.enabled) // Only show enabled sections
                .map(section => ({
                    id: section.sectionId,
                    title: section.title,
                    cards: this.createCardsForSection(section)
                }));
                
            console.log('‚úÖ Loaded sections:', this.sections.length);
        } catch (error) {
            console.error('‚ùå Error loading sections:', error);
            // Use default fallback if loading fails
            this.sections = [];
        }
    }

    createCardsForSection(section) {
        if (!section.pages || !Array.isArray(section.pages)) {
            return [];
        }

        // Get available pages from centralized registry
        const availablePages = getAvailablePages();
        
        // Convert page registry to card format  
        const pageToCardMap = {};
        Object.entries(availablePages).forEach(([pageId, pageInfo]) => {
            pageToCardMap[pageId] = {
                id: pageId,
                title: pageInfo.name,
                icon: pageInfo.icon,
                page: pageId
            };
        });

        return section.pages
            .map(pageId => pageToCardMap[pageId])
            .filter(card => card !== undefined); // Remove any unknown page IDs
    }

    async renderSections() {
        const container = document.getElementById('home-sections-container');
        if (!container) {
            console.error('Home sections container not found');
            return;
        }

        const userPermissions = await getUserPermissions();
        console.log('üîê User permissions:', userPermissions);

        let html = '';

        for (const section of this.sections) {
            // Filter cards based on user permissions
            const accessibleCards = section.cards.filter(card => 
                userPermissions.includes(card.page)
            );

            // Only show section if user has access to at least one card
            if (accessibleCards.length > 0) {
                html += this.renderSection(section, accessibleCards);
            }
        }

        container.innerHTML = html;
    }

    renderSection(section, cards) {
        return `
            <div class="home-section" data-section="${section.id}">
                <div class="section-header">
                    <h3 class="section-title">${section.title}</h3>
                </div>
                <div class="cards-carousel">
                    <div class="cards-container">
                        ${cards.map(card => this.renderCard(card)).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    renderCard(card) {
        return `
            <div class="home-card" data-page="${card.page}">
                <div class="card-icon">${card.icon}</div>
                <div class="card-title">${card.title}</div>
            </div>
        `;
    }

    setupEventListeners() {
        const container = document.getElementById('home-sections-container');
        if (!container) return;

        // Add click listeners to cards
        container.addEventListener('click', (event) => {
            const card = event.target.closest('.home-card');
            if (card) {
                const page = card.dataset.page;
                if (page) {
                    console.log('üéØ Navigating to page:', page);
                    window.location.hash = `#${page}`;
                }
            }
        });

        // Add horizontal scroll support for touch devices
        const carousels = container.querySelectorAll('.cards-carousel');
        carousels.forEach(carousel => {
            let isDown = false;
            let startX;
            let scrollLeft;

            carousel.addEventListener('mousedown', (e) => {
                isDown = true;
                carousel.classList.add('active');
                startX = e.pageX - carousel.offsetLeft;
                scrollLeft = carousel.scrollLeft;
            });

            carousel.addEventListener('mouseleave', () => {
                isDown = false;
                carousel.classList.remove('active');
            });

            carousel.addEventListener('mouseup', () => {
                isDown = false;
                carousel.classList.remove('active');
            });

            carousel.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - carousel.offsetLeft;
                const walk = (x - startX) * 2;
                carousel.scrollLeft = scrollLeft - walk;
            });
        });
    }

    async refreshSections() {
        console.log('üîÑ Refreshing home sections...');
        await this.renderSections();
        this.setupEventListeners();
    }

    setupHeroImage() {
        // Set up hero image with admin upload or fallback to default images
        const heroBackground = document.getElementById('heroBackground');
        if (heroBackground) {
            console.log('üñºÔ∏è Hero background element found, loading image...');
            this.loadHeroImage(heroBackground);
        } else {
            console.error('‚ùå Hero background element not found!');
        }
    }

    async loadHeroImage(heroBackground) {
        try {
            // Try to load admin-uploaded hero image first
            const heroImageData = await this.getHeroImageFromFirestore();
            
            if (heroImageData && heroImageData.imageUrl) {
                console.log('üñºÔ∏è Loading admin hero image:', heroImageData.fileName);
                
                // Handle base64 images with CSP restrictions
                if (heroImageData.imageUrl.startsWith('data:')) {
                    try {
                        // Convert base64 to blob URL for CSP compliance
                        const byteCharacters = atob(heroImageData.imageUrl.split(',')[1]);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: 'image/jpeg' });
                        const blobUrl = URL.createObjectURL(blob);
                        
                        heroBackground.classList.add('has-image');
                        heroBackground.style.backgroundImage = `url(${blobUrl})`;
                        heroBackground.style.backgroundSize = 'cover';
                        heroBackground.style.backgroundPosition = 'center';
                        console.log('‚úÖ Admin hero image loaded successfully');
                        return;
                    } catch (error) {
                        console.error('Error converting base64 to blob:', error);
                    }
                } else {
                    // Regular URL
                    heroBackground.classList.add('has-image');
                    heroBackground.style.backgroundImage = `url(${heroImageData.imageUrl})`;
                    heroBackground.style.backgroundSize = 'cover';
                    heroBackground.style.backgroundPosition = 'center';
                    console.log('‚úÖ Admin hero image loaded successfully');
                    return;
                }
            } else {
                console.log('üñºÔ∏è No admin hero image found, using defaults');
            }
        } catch (error) {
            console.error('Error loading admin hero image:', error);
        }
        
        // Fallback to default images if no admin image
        console.log('üñºÔ∏è Loading default hero image');
        const defaultImages = [
            'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?ixlib=rb-4.0.3&auto=format&fit=crop&w=1920&q=80', // Mountain landscape
            'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?ixlib=rb-4.0.3&auto=format&fit=crop&w=1920&q=80', // Forest path
            'https://images.unsplash.com/photo-1469474968028-56623f02e42e?ixlib=rb-4.0.3&auto=format&fit=crop&w=1920&q=80'  // Nature scene
        ];
        
        // Use a random image for now
        const randomImage = defaultImages[Math.floor(Math.random() * defaultImages.length)];
        
        // Load image with fallback
        const img = new Image();
        img.onload = () => {
            heroBackground.classList.add('has-image');
            heroBackground.style.backgroundImage = `url(${randomImage})`;
            heroBackground.style.backgroundSize = 'cover';
            heroBackground.style.backgroundPosition = 'center';
            console.log('‚úÖ Default hero image loaded successfully');
        };
        img.onerror = () => {
            // Fallback to gradient if image fails to load
            console.log('üñºÔ∏è Hero image failed to load, using gradient fallback');
            heroBackground.classList.remove('has-image');
            heroBackground.style.backgroundImage = 'none';
        };
        img.src = randomImage;
    }

    async getHeroImageFromFirestore() {
        try {
            const { doc, getDoc } = await import('firebase/firestore');
            const { db } = await import('../auth.js');
            
            const heroImageRef = doc(db, 'settings', 'heroImage');
            const docSnap = await getDoc(heroImageRef);
            
            if (docSnap.exists()) {
                return docSnap.data();
            } else {
                return null;
            }
        } catch (error) {
            console.error('Error getting hero image from Firestore:', error);
            return null;
        }
    }

    // Action Items Management
    async loadActionItems() {
        try {
            const { collection, getDocs, query, where } = await import('firebase/firestore');
            const { db, getCurrentUser } = await import('../auth.js');
            
            // Get current user
            const currentUser = getCurrentUser();
            if (!currentUser) {
                console.log('‚ö†Ô∏è No user logged in, skipping action items');
                this.renderEmptyActionItems();
                return;
            }

            const userEmail = currentUser.email;
            console.log('üîç Loading action items for user:', userEmail);
            
            // Load action items assigned to current user that are NOT completed
            // Note: Removed orderBy to avoid composite index requirement
            const actionItemsRef = collection(db, 'actionItems');
            const q = query(
                actionItemsRef,
                where('assignedTo', 'array-contains', userEmail),
                where('completed', '==', false)
            );
            
            console.log('üìä Executing Firestore query...');
            const querySnapshot = await getDocs(q);
            
            const actionItems = [];
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                console.log('üìÑ Found action item:', doc.id, data.title);
                actionItems.push({
                    id: doc.id,
                    ...data
                });
            });

            // Sort by due date in JavaScript instead of Firestore
            actionItems.sort((a, b) => {
                const dateA = a.dueDate?.toDate ? a.dueDate.toDate() : new Date(a.dueDate);
                const dateB = b.dueDate?.toDate ? b.dueDate.toDate() : new Date(b.dueDate);
                return dateA - dateB;
            });

            console.log(`‚úÖ Loaded ${actionItems.length} uncompleted action items`);
            
            if (actionItems.length === 0) {
                this.renderEmptyActionItems();
            } else {
                this.renderActionItems(actionItems);
            }
        } catch (error) {
            console.error('‚ùå Error loading action items:', error);
            console.error('Error code:', error.code);
            console.error('Error message:', error.message);
            
            // Show empty state instead of sample data
            this.renderEmptyActionItems();
        }
    }

    renderEmptyActionItems() {
        const container = document.getElementById('action-items-list');
        if (!container) return;

        container.innerHTML = `
            <div class="empty-state" style="text-align: center; padding: var(--spacing-xl); color: var(--text-secondary);">
                <p>üéâ All caught up! No pending action items.</p>
            </div>
        `;
    }

    renderActionItems(actionItems) {
        const container = document.getElementById('action-items-list');
        if (!container) return;

        if (actionItems.length === 0) {
            this.renderEmptyActionItems();
            return;
        }

        const html = actionItems.map(item => this.renderActionItem(item)).join('');
        container.innerHTML = html;
        
        // Add click listeners for checkboxes
        this.setupActionItemListeners();
    }

    renderDefaultActionItems() {
        // Show sample action items for demonstration
        const defaultItems = [
            {
                id: 'sample-1',
                title: 'Submit Congregation Monthly Report',
                subtitle: 'Monthly administrative report due',
                dueDate: new Date('2025-10-20'),
                completed: false
            },
            {
                id: 'sample-2', 
                title: 'Expiring Application',
                subtitle: 'Review and renew application',
                dueDate: new Date('2025-11-13'),
                completed: false
            }
        ];

        console.log('üìù Showing sample action items (no tasks found in database)');
        this.renderActionItems(defaultItems);
    }

    renderActionItem(item) {
        // Handle Firestore Timestamp objects
        let dueDate;
        if (item.dueDate?.toDate) {
            // Firestore Timestamp
            dueDate = item.dueDate.toDate();
        } else if (item.dueDate instanceof Date) {
            dueDate = item.dueDate;
        } else {
            dueDate = new Date(item.dueDate);
        }
        
        const today = new Date();
        const diffTime = dueDate.getTime() - today.getTime();
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        let dueBadge = '';
        let dueClass = '';
        
        if (diffDays < 0) {
            dueBadge = 'Overdue';
            dueClass = 'overdue';
        } else if (diffDays <= 7) {
            dueBadge = `Due in ${diffDays} day${diffDays === 1 ? '' : 's'}`;
            dueClass = 'due-soon';
        } else if (diffDays <= 30) {
            dueBadge = `Due in ${Math.ceil(diffDays / 7)} week${Math.ceil(diffDays / 7) === 1 ? '' : 's'}`;
            dueClass = 'due-later';
        } else {
            dueBadge = 'Due next month';
            dueClass = 'due-later';
        }

        const formattedDate = dueDate.toLocaleDateString('en-US', { 
            weekday: 'short', 
            month: 'short', 
            day: 'numeric',
            year: 'numeric'
        });

        // Get form type icon
        const formIcon = item.formIcon || 'üìã';
        const formType = item.formType || 'task';
        
        // Show reporting period if available
        const periodInfo = item.reportingPeriod ? 
            `<div class="action-item-period">Period: ${item.reportingPeriod.displayName || 'Not specified'}</div>` : '';

        return `
            <div class="action-item ${item.completed ? 'completed' : ''}" 
                 data-id="${item.id}"
                 data-form-type="${formType}"
                 onclick="openTaskSubmission('${item.id}', '${formType}')"
                 style="cursor: pointer;">
                <div class="action-item-left">
                    <div class="action-item-icon">${formIcon}</div>
                    <div class="action-item-content">
                        <div class="action-item-title">${item.title}</div>
                        ${item.subtitle ? `<div class="action-item-subtitle">${item.subtitle}</div>` : ''}
                        ${periodInfo}
                    </div>
                </div>
                <div class="action-item-right">
                    <div class="action-item-date">${formattedDate}</div>
                    <div class="action-item-due ${dueClass}">${dueBadge}</div>
                    <div class="action-item-arrow">‚Üí</div>
                </div>
            </div>
        `;
    }

    setupActionItemListeners() {
        // Make openTaskSubmission globally available
        window.openTaskSubmission = async (itemId, formType) => {
            try {
                console.log('üìã Opening task submission:', itemId, formType);
                
                // Get the action item data from Firestore
                const { doc, getDoc } = await import('firebase/firestore');
                const { db } = await import('../auth.js');
                
                const itemRef = doc(db, 'actionItems', itemId);
                const itemDoc = await getDoc(itemRef);
                
                if (!itemDoc.exists()) {
                    console.error('Action item not found:', itemId);
                    return;
                }
                
                const itemData = itemDoc.data();
                
                // Navigate to the appropriate form page based on formType
                const formTypeToRoute = {
                    'monthly-availability': 'monthly-availability',
                    'monthly-field-service': 'monthly-field-service',
                    'monthly-attendance': 'monthly-attendance',
                    'monthly-territory': 'monthly-territory',
                    'pioneer-application': 'pioneer-application',
                    'application-renewal': 'application-renewal'
                };
                
                const route = formTypeToRoute[formType] || 'monthly-availability';
                
                // Store task ID in URL params for reference
                const url = new URL(window.location);
                url.searchParams.set('taskId', itemId);
                
                // Navigate to the form page
                console.log('üîÑ Navigating to:', route);
                window.navigateTo(route);
                
            } catch (error) {
                console.error('Error opening task submission:', error);
                const { showNotification } = await import('../utils/notifications.js');
                showNotification('Error opening form', 'error');
            }
        };
    }
                
                await updateDoc(itemRef, {
                    completed: true,
                    completedAt: serverTimestamp(),
                    completedBy: currentUser ? currentUser.email : 'unknown'
                });

                console.log(`‚úÖ Action item ${itemId} marked as completed`);
                
                // Fade out and remove the item from view
                actionItem.style.transition = 'opacity 0.3s, transform 0.3s';
                actionItem.style.opacity = '0';
                actionItem.style.transform = 'translateX(20px)';
                
                setTimeout(() => {
                    // Reload action items to update the list
                    this.loadActionItems();
                }, 300);

            } catch (error) {
                console.error('Error opening task submission:', error);
                const { showNotification } = await import('../utils/notifications.js');
                showNotification('Error opening form', 'error');
            }
        };
    }
}

export { HomePageManager };